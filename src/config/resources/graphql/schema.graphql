# ----------------------------------------------------------------------
# Schema-Definition
# ----------------------------------------------------------------------
schema {
  query: Query
  mutation: Mutation
}

# ----------------------------------------------------------------------
# LESE-OPERATIONEN (Behebt deinen Fehler)
# ----------------------------------------------------------------------
"Funktionen, um Vereinsdaten zu lesen"
type Query {
  "Sucht mehrere Vereine anhand von Suchparametern"
  fussballvereine(
    suchparameter: FussballvereinSuchparameterInput
  ): [Fussballverein!]

  "Sucht einen einzelnen Verein anhand seiner ID"
  fussballverein(id: ID!): Fussballverein
}

# ----------------------------------------------------------------------
# SCHREIB-OPERATIONEN
# ----------------------------------------------------------------------
"Funktionen, um Vereine neu anzulegen, zu aktualisieren oder zu löschen"
type Mutation {
  "Legt einen neuen Fussballverein an"
  create(input: FussballvereinInput!): CreatePayload

  "Aktualisiert einen bestehenden Fussballverein"
  update(input: FussballvereinUpdateInput!): UpdatePayload

  "Löscht einen Fussballverein anhand seiner ID"
  delete(id: ID!): DeletePayload

  # Auth-Mutationen
  token(username: String!, password: String!): TokenPayload
  refresh(refreshToken: String!): TokenPayload
}

# ----------------------------------------------------------------------
# OBJEKT-TYPEN (Das Senden wir an den Client)
# ----------------------------------------------------------------------

"Daten zum Stadion eines Vereins (1:1-Beziehung)"
type Stadion {
  id: ID!
  stadt: String!
  kapazitaet: Int!
  strasse: String
  hausnummer: String
}

"Daten zu einem Spieler (Teil der 1:n-Beziehung)"
type Spieler {
  id: ID!
  vorname: String!
  nachname: String!
  alter: Int
  starkerFuss: String
}

"Datenschema zu einem Fussballverein, der gelesen wird"
type Fussballverein {
  id: ID!
  version: Int!
  name: String!
  gruendungsdatum: String
  website: String
  email: String
  telefonnummer: String
  mitgliederanzahl: Int

  "1:1-Beziehung zum Stadion"
  stadion: Stadion

  "1:n-Beziehung zu den Spielern"
  spieler: [Spieler!]

  # Das Logo (bytea) wird über den REST-Endpunkt (GET /rest/logo/:id)
  # ausgeliefert und ist daher nicht Teil des GraphQL-Schemas.
}

# ----------------------------------------------------------------------
# INPUT-TYPEN (Das Empfangen wir vom Client)
# ----------------------------------------------------------------------

"Suchparameter für die Vereinssuche (Query)"
input FussballvereinSuchparameterInput {
  name: String
  mitgliederanzahl: Int
  # Du kannst hier weitere Filter hinzufügen, z.B. stadt aus Stadion
}

"Daten für ein neues Stadion (Teil von FussballvereinInput)"
input StadionInput {
  stadt: String!
  kapazitaet: Int!
  strasse: String
  hausnummer: String
}

"Daten für einen neuen Spieler (Teil von FussballvereinInput)"
input SpielerInput {
  vorname: String!
  nachname: String!
  alter: Int
  starkerFuss: String
}

"Daten für einen neuen Fussballverein (Mutation)"
input FussballvereinInput {
  name: String!
  gruendungsdatum: String
  website: String
  email: String
  telefonnummer: String
  mitgliederanzahl: Int

  "Optionale 1:1-Beziehung beim Erstellen"
  stadion: StadionInput

  "Optionale 1:n-Beziehung beim Erstellen"
  spieler: [SpielerInput!]
}

"Daten für ein zu änderndes Buch (Mutation)"
input FussballvereinUpdateInput {
  # ID und Version kommen aus Param/Header, nicht aus dem Body
  name: String
  gruendungsdatum: String
  website: String
  email: String
  telefonnummer: String
  mitgliederanzahl: Int
  # Das Ändern von Relationen (Stadion/Spieler) wird hier
  # der Einfachheit halber weggelassen
}

# ----------------------------------------------------------------------
# PAYLOAD-TYPEN (Generische Antworten)
# ----------------------------------------------------------------------

"Generierte ID bei erfolgreichem Neuanlegen"
type CreatePayload {
  id: ID
}

"Neue Versionsnummer als Resultat bei erfolgreichem Aktualisieren"
type UpdatePayload {
  version: Int
}

"Flag, ob das Loeschen durchgefuehrt wurde"
type DeletePayload {
  success: Boolean
}

"Access- und Refresh-Token (Auth)"
type TokenPayload {
  access_token: String!
  expires_in: Int!
  refresh_token: String!
  refresh_expires_in: Int!
}
